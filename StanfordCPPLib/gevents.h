/*
 * File: gevents.h
 * ---------------
 * This interface defines the event types used in the
 * <code>StanfordCPPLib</code> graphics libraries.  The structure
 * of this package is adapted from the Java event model.
 */

#ifndef _gevents_h
#define _gevents_h

#include <string>
#include "gwindow.h"

/*
 * Type: EventClassType
 * --------------------
 * This enumeration type defines the event classes.
 */

enum EventClassType {
   NULL_EVENT,         /* Indicates an uninitialized event              */
   WINDOW_EVENT,       /* Indicates a window-system event               */
   ACTION_EVENT,       /* Indicates an event with an associated action  */
   TIMER_EVENT,        /* Indicates an interval timer event             */
   MOUSE_EVENT,        /* Indicates a mouse event                       */
   KEY_EVENT           /* Indicates an event generated by the keyboard  */
};

/*
 * Type: WindowEventType
 * ---------------------
 * This enumeration type defines the event types for window events.
 */

enum WindowEventType {
   WINDOW_ACTIVATED,   /* Generated when the window gains focus         */
   WINDOW_CLOSED,      /* Generated when the window is finally closed   */
   WINDOW_CLOSING,     /* Generated when the user clicks the close box  */
   WINDOW_DEACTIVATED, /* Generated when the window loses focus         */
   WINDOW_DEICONIFIED, /* Generated when the window is expanded         */
   WINDOW_ICONIFIED,   /* Generated when the window is minimized        */
   WINDOW_OPENED       /* Generated when the window is opened           */
};

/*
 * Type: ActionEventType
 * ---------------------
 * This enumeration type defines the event types for action events.
 */

enum ActionEventType {
   ACTION_PERFORMED    /* Generated when a user action is performed     */
};

/*
 * Type: TimerEventType
 * --------------------
 * This enumeration type defines the event types for timer events.
 */

enum TimerEventType {
   TIMER_TICKED        /* Generated when the interval timer ticks       */
};

/*
 * Type: MouseEventType
 * --------------------
 * This enumeration type defines the event types for mouse events.
 */

enum MouseEventType {
   MOUSE_PRESSED,      /* Generated when the mouse button is pressed     */
   MOUSE_RELEASED,     /* Generated when the mouse button is released    */
   MOUSE_CLICKED,      /* Generated on clicks after PRESSED and RELEASED */
   MOUSE_MOVED,        /* Generated when the mouse is moved              */
   MOUSE_DRAGGED       /* Generated on mouse motion with the button down */
};

/*
 * Type: KeyEventType
 * ------------------
 * This enumeration type defines the event types for keyboard events.
 */

enum KeyEventType {
   KEY_PRESSED,        /* Generated when a key is pressed                */
   KEY_RELEASED,       /* Generated when a key is released               */
   KEY_TYPED           /* Generated after PRESSED and RELEASED on a key  */
};

/*
 * Type: ModifierCodes
 * -------------------
 * This enumeration type defines a set of constants used to check whether
 * modifiers are in effect.
 */

enum ModifierCodes {
   SHIFT_DOWN     = 1 << 0,
   CTRL_DOWN      = 1 << 1,
   META_DOWN      = 1 << 2,
   ALT_DOWN       = 1 << 3,
   ALT_GRAPH_DOWN = 1 << 4,
   BUTTON1_DOWN   = 1 << 5,
   BUTTON2_DOWN   = 1 << 6,
   BUTTON3_DOWN   = 1 << 7
};

/*
 * Type: KeyCodes
 * --------------
 * This enumeration type defines the constants for the special keys on the
 * keyboard.  These values begin after the <code>char</code> range.
 */

enum KeyCodes {
   ESCAPE_KEY = 256,
   DELETE_KEY,
   TAB_KEY,
   RETURN_KEY,
   CLEAR_KEY,
   ENTER_KEY,
   UP_ARROW_KEY,
   DOWN_ARROW_KEY,
   LEFT_ARROW_KEY,
   RIGHT_ARROW_KEY,
   HELP_KEY,
   HOME_KEY,
   PAGE_UP_KEY,
   PAGE_DOWN_KEY,
   FORWARD_DEL_KEY,
   END_KEY,
   F1_KEY,
   F2_KEY,
   F3_KEY,
   F4_KEY,
   F5_KEY,
   F6_KEY,
   F7_KEY,
   F8_KEY,
   F9_KEY,
   F10_KEY,
   F11_KEY,
   F12_KEY,
   F13_KEY,
   F14_KEY,
   F15_KEY,
};

/* Forward definitions */

class GWindowEvent;
class GActionEvent;
class GTimerEvent;
class GMouseEvent;
class GKeyEvent;

/*
 * Class: GEvent
 * -------------
 * This class is the root of the hierarchy for all events.  The
 * primary purpose of this general class is as the parameter to
 * the <code>waitForEvent</code> and <code>getNextEvent</code>
 * functions.  Code that uses these functions to wait for events
 * of more than one class must typically cast the event to the
 * appropriate subclass, as illustrated in the sample code that
 * accompanies the prototypes for those functions.
 */

class GEvent {

public:

/*
 * Constructor: GEvent
 * Usage: GEvent event;
 * --------------------
 * Ensures that an event is properly initialized to a <code>NULL</code>
 * event.
 */

   GEvent();

/*
 * Method: getEventClass
 * Usage: EventClassType eventClass = e.getEventClass();
 * -----------------------------------------------------
 * Returns the enumerated type constant indicating the class of the
 * event.
 */

   EventClassType getEventClass() const;

/*
 * Method: getEventTime
 * Usage: double time = e.getEventTime();
 * --------------------------------------
 * Returns the system time in milliseconds at which the event occurred.
 * To ensure portability among systems that represent time in different
 * ways, the StanfordCPPLib packages use type <code>double</code> to
 * represent time, which is always encoded as the number of milliseconds
 * that have elapsed since 00:00:00 UTC on January 1, 1970, which is
 * the conventional zero point for computer-based time systems.
 */

   double getEventTime() const;

/*
 * Method: getModifiers
 * Usage: int modifiers = e.getModifiers();
 * ----------------------------------------
 * Returns an integer whose bits indicate what modifiers are in effect.
 * To check whether the shift key is down, for example, one could use
 * the following code:
 *
 *<pre>
 *    if (e.getModifiers() & SHIFT_DOWN) . . .
 *</pre>
 */

   int getModifiers() const;

/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */

   virtual std::string toString() const;

/*
 * Operator: bool
 * Usage: if (e) . . .
 * -------------------
 * Converts the event to a Boolean value which is <code>true</code> if the
 * event is valid.
 */

   operator bool() const;

#include "private/geventpriv.h"

};

/*
 * Function: startIntervalTimer
 * Usage: startIntervalTimer(delay);
 *        startIntervalTimer(delay, count);
 * ----------------------------------------
 * Starts an interval timer that fires a timer event repeatedly every
 * <code>delay</code> milliseconds.  The <code>count</code> parameter,
 * if specified, indicates the maximum number of events to fire; if
 * this parameter is missing, the timer continues to fire until it is
 * stopped.
 */

void startIntervalTimer(double delay);
void startIntervalTimer(double delay, int count);

/*
 * Function: stopIntervalTimer
 * Usage: stopIntervalTimer();
 * ---------------------------
 * Stops the interval timer.
 */

void stopIntervalTimer();

/*
 * Function: postEvent
 * Usage: postEvent(e);
 * --------------------
 * Adds the event to the end of the event queue.
 */

void postEvent(GEvent e);

/*
 * Function: waitForEvent
 * Usage: waitForEvent(e);
 * -----------------------
 * Dismisses the process until an event occurs.  When it does, the
 * <code>waitForEvent</code> function returns with the details of
 * the event.  The parameter <code>e</code> can be either a general
 * <code>GEvent</code> variable or one of the specific subclasses.
 * In the former case, the function returns when any event occurs.
 * Clients should use this approach if they need to respond to more
 * than one class of event.  As an example, the following code is
 * the canonical event loop for an animated application that
 * needs to respond to mouse, key, and timer events:
 *
 *<pre>
 *    startIntervalTimer(ANIMATION_DELAY_IN_MILLISECONDS);
 *    while (true) {
 *       GEvent e;
 *       waitForEvent(e);
 *       switch (e.getEventClass()) {
 *        case TIMER_EVENT:
 *          takeAnimationStep();
 *          break;
 *        case MOUSE_EVENT:
 *          handleMouseEvent(GMouseEvent(e));
 *          break;
 *        case KEY_EVENT:
 *          handleKeyEvent(GKeyEvent(e));
 *          break;
 *       }
 *    }
 *</pre>
 *
 * For applications that are interested only in mouse events,
 * for example, this code can be simplified as follows:
 *
 *<pre>
 *    while (true) {
 *       GMouseEvent e;
 *       waitForEvent(e);
 *       handleMouseEvent(e);
 *    }
 *</pre>
 */

void waitForEvent(GEvent & e);
void waitForEvent(GWindowEvent & e);
void waitForEvent(GActionEvent & e);
void waitForEvent(GTimerEvent & e);
void waitForEvent(GMouseEvent & e);
void waitForEvent(GKeyEvent & e);

/*
 * Function: waitForClick
 * Usage: waitForClick();
 *        waitForClick(mouseEvent);
 * --------------------------------
 * Waits for a mouse click to occur anywhere in the window, discarding
 * any other events.  If the client passes a <code>GMouseEvent</code>
 * as a reference parameter, the function will fill in the details of
 * the click event.
 */

void waitForClick();
void waitForClick(GMouseEvent & mouseEvent);

/*
 * Function: getNextEvent
 * Usage: if (getNextEvent(e)) . . .
 * ---------------------------------
 * Checks to see if there are any events waiting on the event queue.
 * If so, <code>getNextEvent</code> fills in the structure of the event
 * with the first event in the queue and returns <code>true</code>.  If
 * there are no events, <code>getNextEvent</code> returns <code>false</code>.
 * As with <code>waitForEvent</code>, the parameter <code>e</code> can
 * be either a <code>GEvent</code> variable or one of the specific
 * subclasses.  Clients should use this form of the call if they
 * need to support animation in the main thread, as in the following
 * code example:
 *
 *<pre>
 *    while (true) {
 *       GEvent e;
 *       if (getNextEvent(e)) {
 *          switch (e.getEventClass()) {
 *           case MOUSE_EVENT:
 *             handleMouseEvent(GMouseEvent(e));
 *             break;
 *           case KEY_EVENT:
 *             handleKeyEvent(GKeyEvent(e));
 *             break;
 *          }
 *       } else {
 *          takeAnimationStep();
 *       }
 *    }
 *</pre>
 */

bool getNextEvent(GEvent & e);
bool getNextEvent(GWindowEvent & e);
bool getNextEvent(GActionEvent & e);
bool getNextEvent(GTimerEvent & e);
bool getNextEvent(GMouseEvent & e);
bool getNextEvent(GKeyEvent & e);

/*
 * Class: GWindowEvent
 * -------------------
 * This event subclass represents a window event.
 */

class GWindowEvent : public GEvent {

public:

/*
 * Constructor: GWindowEvent
 * Usage: GWindowEvent windowEvent;
 *        GWindowEvent windowEvent(e);
 *        GWindowEvent windowEvent(type, gw);
 * ------------------------------------------
 * Creates a <code>GWindowEvent</code> using the specified parameters or
 * those taken from the more general event <code>e</code>.
 */

   GWindowEvent();
   GWindowEvent(GEvent e);
   GWindowEvent(WindowEventType type, GWindow gw);

/*
 * Method: getEventType
 * Usage: WindowEventType type = e.getEventType();
 * -----------------------------------------------
 * Returns the enumerated type constant corresponding to the specific
 * type of window event.
 */

   WindowEventType getEventType() const;

/*
 * Method: getWindow
 * Usage: GWindow gw = e.getWindow();
 * ----------------------------------
 * Returns the graphics window in which this event occurred.
 */

   GWindow getWindow() const;

/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */

   std::string toString() const;

};

/*
 * Class: GActionEvent
 * -------------------
 * This event subclass represents an action event.
 */

class GActionEvent : public GEvent {

public:

/*
 * Constructor: GActionEvent
 * Usage: GActionEvent actionEvent;
 *        GActionEvent actionEvent(e);
 *        GActionEvent actionEvent(type, actionCommand);
 * -----------------------------------------------------
 * Creates a <code>GActionEvent</code> using the specified parameters or
 * those taken from the more general event <code>e</code>.
 */

   GActionEvent();
   GActionEvent(GEvent e);
   GActionEvent(ActionEventType type, std::string actionCommand);

/*
 * Method: getEventType
 * Usage: ActionEventType type = e.getEventType();
 * -----------------------------------------------
 * Returns the enumerated type constant corresponding to the specific
 * type of action event.
 */

   ActionEventType getEventType() const;

/*
 * Method: getActionCommand
 * Usage: string cmd = e.getActionCommand();
 * -----------------------------------------
 * Returns the action command associated with this event.
 */

   std::string getActionCommand() const;

/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */

   std::string toString() const;

};

/*
 * Class: GTimerEvent
 * ------------------
 * This event subclass represents a timer event.
 */

class GTimerEvent : public GEvent {

public:

/*
 * Constructor: GTimerEvent
 * Usage: GTimerEvent timerEvent;
 *        GTimerEvent timerEvent(e);
 *        GTimerEvent timerEvent(type);
 * ------------------------------------
 * Creates a <code>GTimerEvent</code>.
 */

   GTimerEvent();
   GTimerEvent(GEvent e);
   GTimerEvent(TimerEventType type);

/*
 * Method: getEventType
 * Usage: TimerEventType type = e.getEventType();
 * ----------------------------------------------
 * Returns the enumerated type constant corresponding to the specific
 * type of timer event.
 */

   TimerEventType getEventType() const;

/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */

   std::string toString() const;

};

/*
 * Class: GMouseEvent
 * ------------------
 * This event subclass represents a mouse event.
 */

class GMouseEvent : public GEvent {

public:

/*
 * Constructor: GMouseEvent
 * Usage: GMouseEvent mouseEvent;
 *        GMouseEvent mouseEvent(e);
 *        GMouseEvent mouseEvent(type, x, y);
 * ------------------------------------------
 * Creates a <code>GMouseEvent</code> using the specified parameters or
 * those taken from the more general event <code>e</code>.
 */

   GMouseEvent();
   GMouseEvent(GEvent e);
   GMouseEvent(MouseEventType type, double x, double y);

/*
 * Method: getEventType
 * Usage: MouseEventType type = e.getEventType();
 * ----------------------------------------------
 * Returns the enumerated type constant corresponding to the specific
 * type of mouse event.
 */

   MouseEventType getEventType() const;

/*
 * Method: getX
 * Usage: double x = getX();
 * -------------------------
 * Returns the <i>x</i> coordinate at which the event occurred relative
 * to the window origin at the upper left corner of the window.
 */

   double getX() const;

/*
 * Method: getY
 * Usage: double y = getY();
 * -------------------------
 * Returns the <i>y</i> coordinate at which the event occurred relative
 * to the window origin at the upper left corner of the window.
 */

   double getY() const;

/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */

   std::string toString() const;

};

/*
 * Class: GKeyEvent
 * ----------------
 * This event subclass represents a key event.
 */

class GKeyEvent : public GEvent {

public:

/*
 * Constructor: GKeyEvent
 * Usage: GKeyEvent keyEvent;
 *        GKeyEvent keyEvent(e);
 *        GKeyEvent keyEvent(type, key);
 * -------------------------------------
 * Creates a <code>GKeyEvent</code> using the specified parameters or
 * those taken from the more general event <code>e</code>.
 */

   GKeyEvent();
   GKeyEvent(GEvent e);
   GKeyEvent(KeyEventType type, int key);

/*
 * Method: getEventType
 * Usage: KeyEventType type = e.getEventType();
 * --------------------------------------------
 * Returns the enumerated type constant corresponding to the specific
 * type of key event.
 */

   KeyEventType getEventType() const;

/*
 * Method: getKey
 * Usage: int key = getKey();
 * --------------------------
 * Returns the integer code associated with the key in the event.
 */

   int getKey() const;

/*
 * Method: getChar
 * Usage: char ch = e.getChar();
 * -----------------------------
 * Returns the character code for the key value after applying modifier
 * keys.  For example, if the user types the <code>'a'</code> key with
 * the shift key down, <code>getChar</code> will return <code>'A'</code>.
 * If the key code in the event does not correspond to a character,
 * <code>getChar</code> returns the null character (<code>'\0'</code>).
 */

   char getChar() const;

/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */

   std::string toString() const;

};

#endif
